---
title: "Chapter 4: Spatial Data Operations"
subtitle: "Abuja R Users Group Geocomputation with R Study Group"
author: "Robin Lovelace, Jakub Nowosad, James Muenchow; Presenting - Rasha Elnimeiry with Bilikisu Wunmi Olatunji"
format:
  html:
    toc: true
    theme: cosmo
    code-fold: true
editor: visual
---

# Spatial data operations {#spatial-operations}

```{r, include=FALSE}

# install.packages("sf")
# install.packages("terra")
# install.packages("spData")
# install.packages("spDataLarge", repos = "https://nowosad.r-universe.dev")
# Next, install all dependencies required to reproduce the entire book
# (technically they are attached) all installed libraries with the library function as follows:
# remotes::install_github("geocompx/geocompkg", dependencies = TRUE, force = T)
```

## Notes {.unnumbered}

-   **Geocomputation with R Book** (if you want to follow along in the book):\
    <https://r.geocompx.org/spatial-operations>
-   **Abuja R Users Group YouTube Channel** (find all previous sessions here):\
    <https://www.youtube.com/watch?v=opZGLTZTVu0&list=PLnPcq4tuEwaxaXLUrhlBz0zaTp7tj-O7h>
-   **Abuja R Users Group GitHub** page (find all code for after session): <https://github.com/AbujaRUG/Study-Group-GeocompR>
-   This chapter requires packages:
```{r 04-spatial-operations-1, message=FALSE, results='hide'}
library(sf)
library(terra)
library(dplyr)
library(spData)
library(tmap)
library(tidyverse)
```

# 4.1 Introduction
- **Spatial operations** involve modifying spatial objects based on their location and shape.
- Concepts like **spatial joins** and **subsetting** have non-spatial equivalents, covered in previous chapters.
- **Vector operations** involve spatial subsetting, joining, and aggregation.
- **Raster operations** include local, focal, and zonal operations, as well as map algebra.

# 4.2 Spatial Data Operations on Vectors {#spatial-operations}




```{block2 04-spatial-operations-2, type='rmdnote'}
It is important to note that spatial operations that use two spatial objects rely on both objects having the same coordinate reference system, a topic that was introduced in Section \@ref(crs-intro) and which will be covered in more depth in Chapter \@ref(reproj-geo-data).
```


### 4.2 Spatial Operations on Vector Data

### 4.2.1 Spatial subsetting

-   Spatial **subsetting** is the process of taking a spatial object and returning a new object containing only features that ***relate*** in space to another object.

- **Spatial subsetting** filters features in a spatial object based on their relation to another object.

**subsettingfunctions\*** - use these functions, all you need really/catch all

-   **sf::intersects:** is a 'catch all' topological relation that will return features in the target that *touch*, *cross* or are *within* the source 'subsetting' object.

-   **sf::disjoint** is the opposite of sf::intersects, and will return features in the target that do \***NOT** *touch, cross,* or are *within* the source 'subsetting' object.

**Three ways to to subset data:**

    1. **Using the `[` Operator**: 
```r
points[polygon, , op = st_intersects]
```
  - where `x` is an `sf` object from which a subset of rows will be returned, `y` is the 'subsetting object' and `, op = st_intersects` is an optional argument that specifies the topological relation (also known as the binary predicate) used to do the subsetting.
  - Example: `x[y, , op = st_intersects]` where `x` is the target object, `y` is the subsetting object, and `op` specifies the spatial relationship.
  - Default operation: `st_intersects()`, which returns intersecting features.
    2. **Logical Intermediary**:
```r
sf::st_intersects(x = points, y = polygon) -> intersectingpoints
lengths(intersectingpoints) > 0 -> logicaloutcome
points[logicaloutcome, ]
```

    3. **Using `sf::st_filter`**:
```r
points %>% 
    st_filter(y = polygon, .predicate = st_intersects)
```


  
  
To demonstrate spatial subsetting, we will use the `nz` and `nz_height` datasets in the **spData** package, which contain geographic data on the 16 main regions and 101 highest points in New Zealand, respectively (Figure \@ref(fig:nz-subset)), in a projected coordinate reference system. The following code chunk creates an object representing Canterbury, then uses spatial subsetting to return all high points in the region


### **Real world problem:**

To demonstrate spatial subsetting, we will use the `nz` and `nz_height` datasets in the **spData** package, which contain geographic data on the 16 main regions and 101 highest points in New Zealand, respectively, in a projected coordinate reference system. The following code chunk creates an object representing Canterbury, then uses spatial subsetting to return all high points in the region. - **Objective**: Identify high elevation points within the Canterbury region.

-   **Datasets**: We have these datasets: ***nz_height*** (point), ***nz*** (polygon).\
    We want to subset **points** (elevation points) that fall within a **polygon** (canterbury region).
    -   `nz_height` (points)
    -   `nz` (polygons)
-   **Steps**:
    1.  Ensure both spatial objects are in the same coordinate reference system.
    2.  Use various subsetting methods to identify points within the Canterbury region.

```{r 04-spatial-operations-3}

# become familiar with the nz and nz_height
# disclaimer: assigning operator at the end of the function

nz_height   # (points)
nz          # (polygons)
nz %>% view

```

```{r doublecheck-crs, warning=F}
class(nz)
class(nz_height)

crs(nz)
crs(nz_height)
crs(nz) == crs(nz_height)

```

Three different ways we can use the spatial operation to subset:

1.  **Use the `[` operator** `x[y, , op = st_intersects]` or `x[y, , op = st_disjoint]`

-   Filtering out the specific polygon we need "Canterbury"

```{r subsetting-filter-polygon}
nz %>%  
  filter(Name == "Canterbury") ->canterbury
```

-   Using the `[` operator to subset the points within the specific polygon we need `x[y, ]` \<-- not including any specific subsetting function inside the bracket, will default to the `sf::st_intersects` function.
-   To chose specific **subsetting function\*** use: `x[y, , op = st_intersects]` or `x[y, , op = st_disjoint]`

```{r subsetting-using-bracketop}
nz_height[canterbury, , ] -> points_incanterbury

# points[polygon, , op = st_intersects]
nz_height[canterbury, , op = st_intersects] # same thing

nz_height[canterbury,, op = st_disjoint] -> points_outcanterbury

```

-   get a feel/visualise what we just did using **tmap**:

```{r nz-subset, echo=FALSE, warning=FALSE, message=FALSE}




library(tmap)

tm_shape(nz) + 
  tm_polygons(fill = "white")


tm_shape(nz_height) + 
  tm_symbols(shape = 2, col = "red", size = 0.5, col_alpha = 0.75) 
  
tm_shape(nz) + 
  tm_polygons(fill = "white") +
  tm_shape(nz_height) + 
  tm_symbols(shape = 2, col = "red", size = 0.5, col_alpha = 0.75) +
  tm_title("High Elevation Points 
           in New Zealand") +
  tm_layout(bg.color = "lightblue") ->notsubset


tm_shape(nz) + 
  tm_polygons(fill = "white") +
  tm_shape(canterbury) +
  tm_fill(col = "gray") + 
  tm_shape(points_incanterbury) + 
  tm_symbols(shape = 2, col = "red", size = 0.5, col_alpha = 0.75) +
  tm_title("Points Inside Canterbury
           Using st_intersect") +
  tm_layout(bg.color = "lightblue")-> subsettedcanterbury_intersect


tm_shape(nz) + 
  tm_polygons(fill = "white") +
  tm_shape(canterbury) +
  tm_fill(col = "gray") + 
  tm_shape(points_outcanterbury) + 
  tm_symbols(shape = 1, col = "red", size = 0.5, col_alpha = 0.75) +
  tm_title("Points Outside Canterbury
           Using st_disjoint") +
  tm_layout(bg.color = "lightblue")-> subsettedcanterbury_disjoint




tmap_arrange(notsubset, subsettedcanterbury_intersect,subsettedcanterbury_disjoint, ncol = 2)
```

Like attribute subsetting, the command `x[y, ]` (equivalent to `nz_height[canterbury, ]`) subsets features of a *target* `x` using the contents of a *source* object `y`. Instead of `y` being a vector of class `logical` or `integer`, however, for spatial subsetting both `x` and `y` must be geographic objects. Specifically, objects used for spatial subsetting in this way must have the **class `sf` or `sfc`**: both `nz` and `nz_height` are geographic vector data frames and have the class `sf`, and the result of the operation returns another `sf` object representing the features in the target `nz_height` object that intersect with (in this case high points that are located within) the `canterbury` region.

Various *topological relations* can be used for spatial subsetting which determine the type of spatial relationship that features in the target object must have with the subsetting object to be selected. These include *touches*, *crosses* or *within*, as we will see shortly in Section \@ref(topological-relations).

The default setting `st_intersects` is a 'catch all' topological relation that will return features in the target that *touch*, *cross* or are *within* the source 'subsetting' object.

Alternative spatial operators can be specified with the `op =` argument, as demonstrated in the following command which returns the opposite of `st_intersects()`, points that do not intersect with Canterbury.

### EnGauge: Gauge My Understanding of Subsetting

1.  Fill in the missing

```{r 04-spatial-operations-4, eval=FALSE}
nz_height[canterbury]   ->disjoint  #fill in missing
nz_height[canterbury , op = st_disjoint]

nz_height[canterbury, op = st_intersects]   ->intersect #fill in missing
# st_intersect


#Or 

nz_height %>% 
  sf::st_filter(x=., 
                y= nz %>% dplyr::filter(Name %in% "Canterbury"), .predicate=sf::st_intersects
                ) ->intersectpoints
nz_height %>% 
  sf::st_filter(x=., 
                y= nz %>% dplyr::filter(Name %in% "Canterbury"), .predicate=sf::st_disjoint
                ) ->disjointpoints
tm_shape(nz) + 
  tm_polygons(fill = "white") +
  tm_shape(canterbury) +
  tm_fill(col = "gray") + 
  tm_shape(disjointpoints) + 
  tm_symbols(shape = 2, col = "red", size = 0.5, col_alpha = 0.75) +
  tm_title("High points 
           outside of Canterbury") +
  tm_layout(bg.color = "lightblue") ->disjointplot


tm_shape(nz) + 
  tm_polygons(fill = "white") +
  tm_shape(canterbury) +
  tm_fill(col = "gray") + 
  tm_shape(intersectpoints) + 
  tm_symbols(shape = 2, col = "red", size = 0.5, col_alpha = 0.75) +
  tm_title("High points 
           inside of Canterbury") +
  tm_layout(bg.color = "lightblue") ->intersectplot
  
  tmap_arrange(disjointplot, intersectplot, ncol = 2)

```

2.  Canterbury was the region of New Zealand containing most of the 101 highest points in the country. How many of these high points does the Canterbury region contain?

```{r}

nz  %>% 
  filter(Name == "Canterbury") -> canterbury

nz_height[canterbury, ,op= ] -> canterbury_height
nrow(canterbury_height) 

# 
# # anotherway spatial joining
# nz_height ->heighpoints
# nz        ->polygons
# 
# 
# sf::st_join(x=heighpoints, y=polygons, join= st_within) %>% 
#   group_by(Name, .drop = F) %>% 
#   summarize(count = n()) %>%
#   filter(Name %in% "Canterbury") 
# 

# answer: 70
```

```{block2 04-spatial-operations-5, type='rmdnote'}
Note the empty argument --- denoted with `, ,` --- in the preceding code chunk is included to highlight `op`, the third argument in `[` for `sf` objects.
One can use this to change the subsetting operation in many ways.
`nz_height[canterbury, 2, op = st_disjoint]`, for example, returns the same rows but only includes the second attribute column (see `` sf::`[.sf` `` and the `?sf` for details).
```

```{r block2 ex, eval=F}
nz_height[canterbury, 1, op = st_disjoint] %>% names
nz_height[canterbury, 2, op = st_disjoint] %>% names
nz_height[canterbury, 3, op = st_disjoint] %>% names
nz_height[canterbury,  , op = st_disjoint] %>% names

```

For many applications, this is all you'll need to know about spatial subsetting for vector data: it just works.

2.  **Use the logical intermediary (not really needed; use #1 or #3)**

    `st_intersects(x = points, y = polygon) -> intersectingpointslengths(intersectingpoints) > 0       ->logicaloutcomepoints[logicaloutcome, ]`

    Another way of doing spatial subsetting uses objects returned by topological operators. These objects can be useful in their own right, for example when exploring the graph network of relationships between contiguous regions, but they can also be used for subsetting, as demonstrated in the code chunk below.

```{r 04-spatial-operations-6, out.lines=9}
st_intersects(x = nz_height, y = canterbury) -> intersectingpoints

class(intersectingpoints)

lengths(intersectingpoints) > 0 -> logicaloutcome
nz_height[logicaloutcome, ] ->canterbury_height2
canterbury_height2 %>% nrow

```

-   The above code chunk creates an object of class `sgbp` (a sparse geometry binary predicate, a list of length `x` in the spatial operation) and then converts it into a logical vector `logicaloutcome` (containing only `TRUE` and `FALSE` values, something that can also be used by **dplyr**'s filter function). The function `lengths()` identifies which features in `nz_height` intersect with *any* objects in `y`. In this case 1 is the greatest possible value but for more complex operations one could use the method to subset only features that intersect with, for example, 2 or more features from the source object.

```{block2 04-spatial-operations-7, type='rmdnote'}
Note: another way to return a logical output is by setting `sparse = FALSE` (meaning 'return a dense matrix not a sparse one') in operators such as `st_intersects()`. The command `st_intersects(x = nz_height, y = canterbury, sparse = FALSE)[, 1]`, for example, would return an output identical to `logicaloutcome`.
Note: the solution involving `sgbp` objects is more generalisable though, as it works for many-to-many operations and has lower memory requirements.
```

```{r}

st_intersects(x = nz_height, y = canterbury, sparse = FALSE)[, 1] == logicaloutcome
st_intersects(x = nz_height, y = canterbury, sparse = FALSE)[, 1]->sel_logical2

canterbury_height3 = nz_height[sel_logical2, ]
canterbury_height3 == canterbury_height2

```

3.  **Use the sf::st_filter + .predicate = subsettingfunction**

    `points %>% st_filter(y = polygon, .predicate = st_intersects)`

The same result can be also achieved with the **sf** function `st_filter()` which was [created](https://github.com/r-spatial/sf/issues/1148) to increase compatibility between `sf` objects and **dplyr** data manipulation code:

```{r}
nz_height %>% 
  st_filter(y = canterbury, .predicate = st_intersects)->canterbury_height3
```

```{r 04-spatial-operations-7b-old, eval=FALSE, echo=FALSE}
# Additional tests of subsetting
nz_height  %>% 
  filter(st_intersects(x = ., y = canterbury, sparse = FALSE))->canterbury_height4 #replaced '_' to '.'

nz_height %>%
  filter(logicaloutcome)-> canterbury_height5

identical(canterbury_height3, canterbury_height4)
identical(canterbury_height3, canterbury_height5)

```

The next section explores different types of spatial relation, also known as binary predicates, that can be used to identify whether or not two features are spatially related or not.

### 4.2.2 Topological relations

-   Topological relations: describe the spatial relationships between objects.

-   "Binary topological relationships": are logical statements (in that the answer can only be `TRUE` or `FALSE`) about the spatial relationships between two objects defined by ordered sets of points (typically forming points, lines and polygons) in two or more dimensions [@egenhofer_mathematical_1990].

-   For some relations, order is important.

    -   ***equals***, ***intersects***, ***crosses***, ***touches*** and ***overlaps*** are symmetrical, meaning that if `function(x, y)` is true, `function(y, x)` will also be true, relations in which the order of the geometries are important such as

    -   ***contains*** and ***within*** are not symmetrical.

    -   Notice that each geometry pair has a "**DE-9IM" string** such as FF2F11212, described in the next section. \index{topological relations}

-   relationships;

    -   **Equals**: The two geometries are exactly the same.

    <!-- -->

    -   **Disjoint**: The geometries do not share any points.

    -   **Intersects**: The geometries share at least one point.

    -   **Touches**: The geometries have at least one boundary point in common, but their interiors do not intersect.

    -   **Within**: Geometry A is completely inside Geometry B.

    -   **Contains**: Geometry A completely encloses Geometry B.

    -   **Overlaps**: The geometries share some, but not all, points.

```{r relations, echo=FALSE, fig.cap="Topological relations between vector geometries, inspired by Figures 1 and 2 in Egenhofer and Herring (1990). The relations for which the function(x, y) is true are printed for each geometry pair, with x represented in pink and y represented in blue. The nature of the spatial relationship for each pair is described by the Dimensionally Extended 9-Intersection Model string.", fig.show='hold', message=FALSE, fig.asp=0.66, warning=FALSE}
# source("https://github.com/geocompx/geocompr/raw/main/code/de_9im.R")
source("code/de_9im.R")
library(sf)
xy2sfc = function(x, y) st_sfc(st_polygon(list(cbind(x, y))))
p1 = xy2sfc(x = c(0, 0, 1, 1,   0), y = c(0, 1, 1, 0.5, 0))
p2 = xy2sfc(x = c(0, 1, 1, 0), y = c(0, 0, 0.5, 0))
p3 = xy2sfc(x = c(0, 1, 1, 0), y = c(0, 0, 0.7, 0))
p4 = xy2sfc(x = c(0.7, 0.7, 0.9, 0.7), y = c(0.8, 0.5, 0.5, 0.8))
p5 = xy2sfc(x = c(0.6, 0.7, 1, 0.6), y = c(0.7, 0.5, 0.5, 0.7))
p6 = xy2sfc(x = c(0.1, 1, 1, 0.1), y = c(0, 0, 0.3, 0))
p7 = xy2sfc(x = c(0.05, 0.05, 0.6, 0.5, 0.05), y = c(0.4, 0.97, 0.97, 0.4, 0.4))

# todo: add 3 more with line/point relations?
tmap::tmap_arrange(de_9im(p1, p2), de_9im(p1, p3), de_9im(p1, p4),
                   de_9im(p7, p1), de_9im(p1, p5), de_9im(p1, p6), nrow = 2)
```

In `sf`, functions testing for different types of topological relations are called 'binary predicates', as described in the vignette *Manipulating Simple Feature Geometries*, which can be viewed with the command [`vignette("sf3")`](https://r-spatial.github.io/sf/articles/sf3.html), and in the help page [`?geos_binary_pred`](https://r-spatial.github.io/sf/reference/geos_binary_ops.html). To see how topological relations work in practice, let's create a simple reproducible example, building on the relations illustrated in Figure and consolidating knowledge of how vector geometries are represented from a previous chapter (Section \@ref(geometry)).

Note that to create tabular data representing coordinates (x and y) of the polygon vertices, we use the base R function `cbind()` to create a matrix representing coordinates points, a `POLYGON`, and finally an `sfc` object, as described in Chapter \@ref(spatial-class):

```{r}
polygon_matrix = cbind(
  x = c(0, 0, 1, 1,   0),
  y = c(0, 1, 1, 0.5, 0)
)
polygon_sfc = st_sfc(st_polygon(list(polygon_matrix)))
plot(polygon_sfc)
```

-   Create additional geometries to demonstrate spatial relations with the following commands which, when plotted on top of the polygon created above, relate in space to one another.



-   Use function `st_as_sf()` and the argument `coords` to efficiently convert from a data frame containing columns representing coordinates to an `sf` object containing points:

```{r}
point_df = data.frame(
  x = c(0.2, 0.7, 0.4),
  y = c(0.1, 0.2, 0.8)
)
point_sf = st_as_sf(point_df, coords = c("x", "y"))
plot(point_sf)
```

```{r relation-objects, echo=FALSE, fig.cap="Points, line and polygon objects arranged to illustrate topological relations.", fig.asp=1, out.width="50%", fig.scap="Demonstration of topological relations."}
par(pty = "s")
plot(polygon_sfc, border = "red", col = "gray", axes = TRUE)
plot(point_sf, add = TRUE, lab = 1:4, cex = 2)
text(point_df[, 1] + 0.02, point_df[, 2] + 0.04, 1:3, cex = 1.3)
```

-   A simple query is: which of the points in `point_sf` intersect in some way with polygon `polygon_sfc`? The question can be answered by inspection (points 1 and 3 are touching and within the polygon, respectively). This question can be answered with the spatial predicate `st_intersects()` as follows:

```{r 04-spatial-operations-9, eval=FALSE}
st_intersects(x = point_sf, y=polygon_sfc)
#> Sparse geometry binary predicate... `intersects'
#>  1: 1
#>  2: (empty)
#>  3: 1
```

The result should match your intuition: positive (`1`) results are returned for the first and third point, and a negative result (represented by an empty vector) for the second are outside the polygon's border. What may be unexpected is that the result comes in the form of a list of vectors. This *sparse matrix* output only registers a relation if one exists, reducing the memory requirements of topological operations on multi-feature objects. As we saw in the previous section, a *dense matrix* consisting of `TRUE` or `FALSE` values is returned when `sparse = FALSE`.

```{r 04-spatial-operations-10}
st_intersects(point_sf, polygon_sfc, sparse = FALSE)
```

In the above output each row represents a feature in the target (argument `x`) object and each column represents a feature in the selecting object (`y`). In this case, there is only one feature in the `y` object `polygon_sfc` so the result, which can be used for subsetting as we saw in Section, has only one column.

-   `st_intersects()` returns `TRUE` even in cases where the features just touch: *intersects*\index{intersects} is a 'catch-all' topological operation which identifies many types of spatial relation, as illustrated in Figure \@ref(fig:relations). More restrictive questions include which points lie within the polygon, and which features are on or contain a shared boundary with `y`? These can be answered as follows (results not shown):

```{r 04-spatial-operations-9-2, eval=FALSE}
sf::st_within(point_sf, polygon_sfc)
sf::st_touches(point_sf, polygon_sfc)
```

Note that although **the first point** *touches* the boundary polygon, it is not within it; **the third point** is within the polygon but does not touch any part of its border.

-   The opposite of `st_intersects()` is `st_disjoint()`, which returns only objects that do not spatially relate in any way to the selecting object (note `[, 1]` converts the result into a vector).

```{r 04-spatial-operations-11}
st_disjoint(point_sf, polygon_sfc, sparse = FALSE)[, 1]
```

-   The function `st_is_within_distance()` detects features that *almost touch* the selection object,

-   additional `dist` argument: set how close target objects need to be before they are selected. The 'is within distance' binary spatial predicate is demonstrated in the code chunk below, the results of which show that every point is within 0.2 units of the polygon.

-   distance is measured to the nearest edge, in this case the part of the polygon that lies directly above point 2 i

```{r 04-spatial-operations-14}
st_is_within_distance(point_sf, polygon_sfc, dist = 0.2, sparse = FALSE)[, 1]
```

-   (You can verify the actual distance between point 2 and the polygon is 0.13 with the command `st_distance(point_sf, polygon_sfc)`.)

```{r, eval=FALSE, echo=FALSE}
# verify distances to the polygon with reference to paragraph above:
st_distance(point_sf, polygon_sfc)
#           [,1]
# [1,] 0.0000000
# [2,] 0.1341641
# [3,] 0.0000000
```

```{block2 04-spatial-operations-15, type='rmdnote'}
Functions for calculating topological relations use spatial indices to largely speed up spatial query performance.
They achieve that using the Sort-Tile-Recursive (STR) algorithm.
The `st_join` function, mentioned in the next section, also uses the spatial indexing. 
You can learn more at https://www.r-spatial.org/r/2017/06/22/spatial-index.html.
```

```{r 04-spatial-operations-16, eval=FALSE, echo=FALSE}
# other tests
st_overlaps(point_sf, polygon_sfc, sparse = FALSE)
st_covers(point_sf, polygon_sfc, sparse = FALSE)
st_covered_by(point_sf, polygon_sfc, sparse = FALSE)
st_contains(polygon_sfc, point_sf, sparse = F)
```

```{r 04-spatial-operations-17, eval=FALSE, echo=FALSE}
# st_contains(a, p[2, ], sparse = TRUE) #ddidn't work
```

```{r 04-spatial-operations-18, eval=FALSE, echo=FALSE}
# starting simpler so commented
a1 = st_polygon(list(rbind(c(-1, -1), c(1, -1), c(1, 1), c(-1, -1))))
a2 = st_polygon(list(rbind(c(2, 0), c(2, 2), c(3, 2), c(3, 0), c(2, 0))))
a = st_sfc(a1, a2)

b1 = a1 * 0.5
b2 = a2 * 0.4 + c(1, 0.5)
b = st_sfc(b1, b2)

l1 = st_linestring(x = matrix(c(0, 3, -1, 1), , 2))
l2 = st_linestring(x = matrix(c(-1, -1, -0.5, 1), , 2))
l = st_sfc(l1, l2)

p = st_multipoint(x = matrix(c(0.5, 1, -1, 0, 1, 0.5), , 2))

plot(a, border = "red", axes = TRUE)
plot(b, border = "green", add = TRUE)
plot(l, add = TRUE)
plot(p, add = TRUE)

st_contains(x=a, y=b)
```

### 4.2.3 Distance relations

While the topological relations presented in the previous section are

-   binary (a feature either intersects with another or does not)

-   distance relations are continuous.

    -   The distance between two `sf` objects is calculated with `st_distance()`, which is also used behind the scenes for distance-based joins. This is illustrated in the code chunk below, which finds the distance between the highest point in New Zealand and the geographic centroid of the Canterbury region.

```{r 04-spatial-operations-31, warning=FALSE}
nz_height %>%  
  slice_max(n = 1, order_by = elevation)-> nz_highest

st_centroid(canterbury)->canterbury_centroid 

st_distance(nz_highest, canterbury_centroid)
```

There are two potentially surprising things about the result:

-   It has `units`, telling us the distance is 100,000 meters, not 100,000 inches, or any other measure of distance
-   It is returned as a matrix, even though the result only contains a single value

This second feature hints at another useful feature of `st_distance()`, its ability to return *distance matrices* between all combinations of features in objects `x` and `y`. This is illustrated in the command below, which finds the distances between the first three features in `nz_height` and the Otago and Canterbury regions of New Zealand represented by the object `co`.

```{r 04-spatial-operations-32}
filter(nz, grepl("Canter|Otag", Name))-> co

st_distance(nz_height[1:3, ], co)
```

-   Note that the distance between the second and third features in `nz_height` and the second feature in `co` is zero. This demonstrates the fact that:

-   distances between points and polygons refer to the distance to *any part of the polygon*: The second and third points in `nz_height` are *in* Otago, which can be verified by plotting them (result not shown):

```{r 04-spatial-operations-33, eval=FALSE}
plot(st_geometry(co)[2])
plot(st_geometry(nz_height)[2:3], add = TRUE)
```

### 4.2.4 DE-9IM strings {#de-9im-strings}

DE-9IM: what to know about it:

-   stands for Dimensionally Extended 9-Intersection Model (DE-9IM)

-   framework used to describe the spatial relationships between two geometrical objects. It helps in understanding how these objects interact with each other in terms of their interiors, boundaries, and exteriors. In simple terms, DE-9IM provides a way to precisely define relationships like "intersects," "contains," "touches," and more between spatial features.

-   The model was originally labelled "DE + 9IM" by its inventors, referring to the "dimension of the intersections of boundaries, interiors, and exteriors of two features", but is now referred to as DE-9IM.

-   is applicable to 2-dimensional objects (points, lines and polygons) in Euclidean space, meaning that the model (and software implementing it such as GEOS) assumes you are working with data in a projected coordinate reference system, described in later chapters.

### Understanding DE-9IM in Simple Terms

**DE-9IM (Dimensionally Extended 9-Intersection Model)** is a framework used to describe spatial relationships between two geometrical objects, such as points, lines, and polygons. It provides a precise way to define relationships like "intersects," "contains," "touches," and more.

### Basic Concepts

To demonstrate how DE-9IM strings work, let's take a look at the various ways that the first geometry pair in Figure \@ref(fig:relations) relate. Figure \@ref(fig:de9imgg) illustrates the 9 intersection model (9IM) which shows the intersections between every combination of each object's interior, boundary and exterior: when each component of the first object `x` is arranged as columns and each component of `y` is arranged as rows, a facetted graphic is created with the intersections between each element highlighted.

```{r de9imgg, echo=FALSE, warning=FALSE, fig.cap="Illustration of how the Dimensionally Extended 9 Intersection Model (DE-9IM) works. Colors not in the legend represent the overlap between different components. The thick lines highlight 2 dimensional intesections, e.g., between the boundary of object x and the interior of object y, shown in the middle top facet.", message=FALSE}
p1_2 = st_as_sf(c(p1, p3))
ii = st_as_sf(st_intersection(p1, p3))
ii$Object = "Intersection"
ii$domain_a = "Interior"
ii$domain_b = "Interior"

bi = st_sf(x = st_intersection(
  st_cast(p1, "LINESTRING"),
  st_difference(p3, st_buffer(st_cast(p3, "LINESTRING"), dist = 0.01))
  ))
bi = st_buffer(bi, dist = 0.01)
bi$Object = "Intersection"
bi$domain_a = "Boundary"
bi$domain_b = "Interior"

ei = st_sf(x = st_difference(p3, p1))
ei$Object = "Intersection"
ei$domain_a = "Exterior"
ei$domain_b = "Interior"

ib = st_sf(x = st_intersection(
  st_cast(p3, "LINESTRING"),
  st_difference(p1, st_buffer(st_cast(p1, "LINESTRING"), dist = 0.005))
  ))
ib = st_buffer(ib, dist = 0.01)
ib$Object = "Intersection"
ib$domain_a = "Interior"
ib$domain_b = "Boundary"

bb = st_cast(ii, "POINT")
bb_line = st_sf(x = st_sfc(st_linestring(matrix(c(1, 0.5, 1, 0.7), nrow = 2, byrow = TRUE))))
bb_line_buffer = st_buffer(bb_line, dist = 0.01)
bb_buffer = st_buffer(bb, dist = 0.01)
bb = st_union(bb_buffer, bb_line_buffer)
bb$Object = "Intersection"
bb$domain_a = "Boundary"
bb$domain_b = "Boundary"

eb = st_sf(x = st_difference(
  st_cast(p3, "LINESTRING"),
  p1
  ))
eb = st_buffer(eb, dist = 0.01)
eb$Object = "Intersection"
eb$domain_a = "Exterior"
eb$domain_b = "Boundary"

ie = st_sf(x = st_difference(p1, p3))
ie$Object = "Intersection"
ie$domain_a = "Interior"
ie$domain_b = "Exterior"

be = st_sf(x = st_difference(
  st_cast(p1, "LINESTRING"),
  p3
  ))
be = st_buffer(be, dist = 0.01)
be$Object = "Intersection"
be$domain_a = "Boundary"
be$domain_b = "Exterior"

ee = st_sf(x = st_difference(
  st_buffer(st_union(p1, p3), 0.02),
  st_union(p1, p3)
  ))
ee$Object = "Intersection"
ee$domain_a = "Exterior"
ee$domain_b = "Exterior"

b9 = replicate(p1_2, n = 9, simplify = FALSE)
b9sf = do.call(rbind, b9)
b9sf$Object = rep(c("x", "y"), 9)
domains = c("Interior", "Boundary", "Exterior")
b9sf$domain_a = rep(rep(domains, 3), each = 2)
b9sf$domain_b = rep(rep(domains, each = 3), each = 2)
b9sf = rbind(b9sf, ii, bi, ei, ib, bb, eb, ie, be, ee)
b9sf$domain_a = ordered(b9sf$domain_a, levels = c("Interior", "Boundary", "Exterior"))
b9sf$domain_b = ordered(b9sf$domain_b, levels = c("Interior", "Boundary", "Exterior"))
b9sf = b9sf %>% 
  mutate(alpha = case_when(
   Object == "x" ~ 0.1, 
   Object == "y" ~ 0.1, 
   TRUE ~ 0.2 
  ))
library(ggplot2)
ggplot(b9sf) +
  geom_sf(aes(fill = Object, alpha = alpha)) +
  facet_grid(domain_b ~ domain_a) +
  scale_fill_manual(values = c("red", "lightblue", "yellow"), position = "top", name = "") +
  scale_alpha_continuous(range = c(0.3, 0.9)) +
  guides(alpha = "none") +
  theme_void() +
  theme(legend.position = "top")
```

DE-9IM strings are derived from the dimension of each type of relation. In this case the red intersections in Figure \@ref(fig:de9imgg) have dimensions of 0 (points), 1 (lines), and 2 (polygons), as shown in Table \@ref(tab:de9emtable).

        ```         
                          Interior (x)  | Boundary (x) | Exterior (x)
        ------------------------------------------------------------
        Interior (y)     |      2       |      1       |      2
        ------------------------------------------------------------
        Boundary (y)     |      1       |      1       |      1
        ------------------------------------------------------------
        Exterior (y)     |      2       |      1       |      2
        ```

1.  **Interior, Boundary, Exterior**:
    -   **Interior**: The inside area of a geometric object.
    -   **Boundary**: The edge or perimeter of the object.
    -   **Exterior**: The area outside the object.
2.  **9-Intersection Matrix**:
    -   The model uses a 3x3 matrix to represent the spatial relationship between two geometries (A and B). The matrix looks at the intersections of their interiors, boundaries, and exteriors:

        ```         
                         B Interior  | B Boundary    |  B Exterior
        -----------------------------------------------------------
        A Interior  |   (I,I)        |   (I,B)       |   (I,E)
        -----------------------------------------------------------
        A Boundary  |   (B,I)        |   (B,B)       |   (B,E)
        -----------------------------------------------------------
        A Exterior  |   (E,I)        |   (E,B)       |   (E,E)
        ```

    -   Each cell in the matrix can have a value of 0, 1, or 2, indicating the dimension of the intersection:

        -   **0**: No intersection (empty set)
        -   **1**: Intersection is a line or a point
        -   **2**: Intersection is an area

### Example Matrix

Let's say we have the following DE-9IM matrix for two geometries X and Y:

-   **(I,I) = 2**: The interiors of X and Y intersect in an area (2D).

-   **(I,B) = 1**: The interior of X intersects the boundary of Y in a line or point (1D).

-   **(I,E) = 0**: The interior of X does not intersect the exterior of Y (0D).

-   **(B,I) = 1**: The boundary of X intersects the interior of Y in a line or point (1D).

-   **(B,B) = 1**: The boundaries of X and Y intersect in a line or point (1D).

-   **(B,E) = 0**: The boundary of X does not intersect the exterior of Y (0D).

-   **(E,I) = 0**: The exterior of X does not intersect the interior of Y (0D).

-   **(E,B) = 0**: The exterior of X does not intersect the boundary of Y (0D).

-   **(E,E) = 2**: The exteriors of X and Y intersect in an area (2D).

fill this in:

```         
         Interior (Y) | Boundary (Y) | Exterior (Y)
---------------------------------------------------
Interior (X) |     2       |      1       |     0
---------------------------------------------------
Boundary (X) |     1       |      1       |     0
---------------------------------------------------
Exterior (X) |     0       |      0       |     2
```

### Conclusion

The DE-9IM model helps to precisely define how different parts of two geometries (interior, boundary, and exterior) interact with each other. The values 0, 1, and 2 in the matrix indicate the dimensionality of these intersections, which allows for a detailed and accurate description of their spatial relationship.

### Flattening the Matrix

The matrix can be flattened into a string for easier representation.

Putting these values together in the sequence of (I,I), (I,B), (I,E), (B,I), (B,B), (B,E), (E,I), (E,B), (E,E), the string representation of the matrix is:

**"210110002"**

This string encodes the spatial relationship between X and Y based on the given matrix.

In the DE-9IM string notation, `F` is often used to represent a dimension of 0, indicating that there is no intersection (or that the intersection is empty). So, if we replace the `0`s with `F`s in the string, the modified string would be:

**"21F11F2FF2"**

This string now uses `F` to indicate the absence of intersections where the matrix entries were `0`. The rest of the digits remain the same to represent the dimensionality of the intersections where they do exist.

### Using DE-9IM in R

The `st_relate` function in the `sf` package helps to compute DE-9IM strings:

```{r}
# Define geometries
x = st_sfc(st_polygon(list(cbind(c(0, 0, 1, 1, 0), c(0, 1, 1, 0.5, 0)))))
y = st_sfc(st_polygon(list(cbind(c(0.7, 0.7, 0.9, 0.7), c(0.8, 0.5, 0.5, 0.8)))))

# Compute the DE-9IM string
st_relate(x, y)
```

Understanding DE-9IM strings allows for the development of new spatial predicates and more sophisticated spatial analysis.

```{r de9emtable, echo=FALSE}
# See https://github.com/geocompx/geocompr/issues/699
pattern = st_relate(p1, p3)
matrix_de_9im = function(pattern) {
    string = unlist(strsplit(pattern , ""))
    matrix_de_9im = matrix(string, nrow = 3, byrow = TRUE)
    colnames(matrix_de_9im) = c("I", "B", "E")
    row.names(matrix_de_9im) = c("I", "B", "E")
    return(matrix_de_9im)
}

m = matrix_de_9im(pattern)
colnames(m) = c("Interior (x)", "Boundary (x)", "Exterior (x)")
rownames(m) = c("Interior (y)", "Boundary (y)", "Exterior (y)")
knitr::kable(m, caption = "Table showing relations between interiors, boundaries and exteriors of geometries x and y.")
```

Flattening this matrix 'row-wise' (meaning concatenating the first row, then the second, then the third) results in the string `212111212`. Another example will serve to demonstrate the system: the relation shown in Figure \@ref(fig:relations) (the third polygon pair in the third column and 1st row) can be defined in the DE-9IM system as follows:

-   The intersections between the *interior* of the larger object `x` and the interior, boundary and exterior of `y` have dimensions of 2, 1 and 2 respectively
-   The intersections between the *boundary* of the larger object `x` and the interior, boundary and exterior of `y` have dimensions of F, F and 1 respectively, where 'F' means 'false', the objects are disjoint
-   The intersections between the *exterior* of `x` and the interior, boundary and exterior of `y` have dimensions of F, F and 2 respectively: the exterior of the larger object does not touch the interior or boundary of `y`, but the exterior of the smaller and larger objects cover the same area

These three components, when concatenated, create the string `212`, `FF1`, and `FF2`. This is the same as the result obtained from the function `st_relate()` (see the source code of this chapter to see how other geometries in Figure \@ref(fig:relations) were created):

```{r}
xy2sfc = function(x, y) st_sfc(st_polygon(list(cbind(x, y))))
x = xy2sfc(x = c(0, 0, 1, 1, 0), y = c(0, 1, 1, 0.5, 0))
y = xy2sfc(x = c(0.7, 0.7, 0.9, 0.7), y = c(0.8, 0.5, 0.5, 0.8))
plot(x)
plot(y, add=T)
st_relate(x, y)
```

-   Understanding DE-9IM strings allows new binary spatial predicates to be developed. The help page `?st_relate` contains function definitions for 'queen' and 'rook' relations in which polygons share a border or only a point, respectively.

The content you provided explains how the DE-9IM string pattern is used to define "queen" and "rook" spatial relationships in a grid of polygons, specifically in the context of spatial analysis using the `st_relate` function from the `sf` package in R.

### Queen and Rook Relationships

In spatial analysis, the concepts of "queen" and "rook" refer to different ways of defining neighborhood or adjacency relationships between polygons on a grid:

-   **Queen Relationship**: This is similar to how a queen moves in chess. A queen can move any number of squares along a row, column, or diagonal. In terms of polygons, a "queen" relationship means that two polygons are considered neighbors if they share either a boundary or a point (corner). For this to be true in the DE-9IM string, the boundary-boundary intersection (the 5th element of the string) must not be empty, represented by a `T` (True) in the string: `F***T****`.

-   **Rook Relationship**: This is similar to how a rook moves in chess. A rook can only move along rows and columns, not diagonals. In terms of polygons, a "rook" relationship means that two polygons are considered neighbors if they share a boundary, but not just a point. For this to be true in the DE-9IM string, the boundary-boundary intersection must be exactly 1-dimensional (linear), represented by a `1` in the string: `F***1****`.

### Understanding the DE-9IM String in This Context

The DE-9IM matrix provides a way to describe spatial relationships between two geometries, including points, lines, and polygons. The string is a shorthand way to represent this matrix, with each character corresponding to different parts of the matrix.

For example: - **"**`F***T****`**" (Queen Relation)**: The `T` in the 5th position indicates that the boundaries of the two polygons have a non-empty intersection, which could be a line or point. This is the condition needed for the polygons to be considered "queens" of each other.

-   **"**`F***1****`**" (Rook Relation)**: The `1` in the 5th position specifies that the boundaries of the two polygons intersect in exactly one dimension (a line). This is the condition needed for the polygons to be considered "rooks" of each other.

### Application

In practice, these relationships can be used to analyze spatial data. For example, you might want to identify which polygons in a grid are adjacent to a central polygon using either the "queen" or "rook" definition. The R code provided uses the `st_relate` function to apply these DE-9IM string patterns (`F***T****` for queen and `F***1****` for rook) to determine the relationships between polygons in a spatial grid.

-   **`st_queen(grid, grid[5])`**: Identifies all polygons that are "queen" neighbors to the central polygon (`grid[5]`).

-   **`st_rook(grid, grid[5])`**: Identifies all polygons that are "rook" neighbors to the central polygon.

The results can then be plotted to visually represent these relationships in the grid.

```{r}
st_queen = function(x, y) st_relate(x, y, pattern = "F***T****")
st_rook = function(x, y) st_relate(x, y, pattern = "F***1****")
```

Building on the object `x` created previously, we can use the newly created functions to find out which elements in the grid are a 'queen' and 'rook' in relation to the middle square of the grid as follows:

```{r queens, fig.cap="Demonstration of custom binary spatial predicates for finding 'queen' (left) and 'rook' (right) relations to the central square in a grid with 9 geometries.", echo=FALSE, warning=FALSE}
grid = st_make_grid(x, n = 3)
grid_sf = st_sf(grid)
grid_sf$queens = lengths(st_queen(grid, grid[5])) > 0
# plot(grid, col = grid_sf$queens)
grid_sf$rooks = lengths(st_rook(grid, grid[5])) > 0
# plot(grid, col = grid_sf$rooks)

st_crs(grid_sf) = "EPSG:2180"

tm_shape(grid_sf) +
  tm_fill(fill = c("queens", "rooks"), 
          fill.scale = tm_scale(values = c("white", "black"))) +
  tm_shape(grid_sf) +
  tm_borders(col = "grey", lwd = 2) +
  tm_layout(frame = FALSE, legend.show = FALSE,
            panel.labels = c("queen", "rook"))
```

### 4.2.5 Spatial Joining

In spatial data, joins work similarly to non-spatial joins but instead of relying on a shared key variable, they rely on spatial relationships. Here's a summary of the process:

- **Attribute data joins** add new columns from a source object (`y`) to a target object (`x`), as in non-spatial joins.
- **Spatial joins** work by matching features based on their spatial relationships (e.g., points within polygons).

#### Example: Random Points and Country Names
Imagine you have 10 random points scattered across the Earth's surface. You want to determine which countries these points belong to (if they fall on land). Here's how you can perform a spatial join using R:

1. **Generate random points:**
```{r}
set.seed(2018)
   st_bbox(world) -> bb  # Get the world's bounding box
   data.frame(
     x = runif(n = 10, min = bb[1], max = bb[3]),
     y = runif(n = 10, min = bb[2], max = bb[4])
   ) %>%
     st_as_sf(coords = c("x", "y"), crs = "EPSG:4326") -> random_points

```


2. **Subset countries that contain these points:**
```{r}
   world[random_points, ] -> world_random
```

3. **Visualize the points and matching countries:**
```{r}
   tm_shape(world) +
     tm_polygons(fill = 'white') +
     tm_shape(world_random) +
     tm_bubbles(size = .75) +
     tm_shape(world_random) +
     tm_polygons(fill = "red", fill_alpha = .45)
```

   
4. **Perform a spatial join to add country names to points:**
```{r}
   st_join(x = random_points, left = FALSE, y = world["name_long"]) -> random_joined

```

- **Left Join**: The default join type (`left = TRUE`) keeps all rows from `x`, adding `y`'s attributes where spatial matches exist.
- **Inner Join**: Set `left = FALSE` for an inner join, where only matching rows from both `x` and `y` are kept.

5. **Visualize the result:**
```{r}


   tm_shape(world) + 
     tm_polygons(fill = "white") +
     tm_shape(random_joined) +
     tm_bubbles(size = .75) +
     tm_shape(world_random) +
     tm_polygons(fill = "red", fill_alpha = .3)
```

#### Key Notes:
- The topological operator used by `st_join()` is `st_intersects()` by default, but can be changed using the `join` argument.
- Spatial joins are flexible across geometry types (e.g., points to polygons, lines to polygons). If multiple matches exist (e.g., a polygon matches multiple points), the result will contain duplicates.

This process illustrates how to enrich spatial data by joining attributes from different layers based on their spatial relationships.

### 4.2.6 Distance-based joins {#non-overlapping-joins}

-   Sometimes geographic datasets are not overlapping but still have a close geographic relationship due to proximity.
-   An example involves `cycle_hire` and `cycle_hire_osm` datasets from the **spData** package. These datasets are close but do not intersect.

To visualize the datasets:

```{r}
plot(st_geometry(cycle_hire), col = "blue")
plot(st_geometry(cycle_hire_osm), add = TRUE, pch = 3, col = "red")

library(leaflet)
leaflet() %>%
  addCircles(data = cycle_hire) %>%
  addCircles(data = cycle_hire_osm, col = "red")
```

-   Check if the points intersect:

```{r}
any(st_intersects(cycle_hire, cycle_hire_osm, sparse = FALSE))
```

-   Alternative methods to check overlap:

```{r}
sum(st_geometry(cycle_hire) %in% st_geometry(cycle_hire_osm))
sum(st_coordinates(cycle_hire)[, 1] %in% st_coordinates(cycle_hire_osm)[, 1])
```

-   A non-overlapping join is needed to link data from `cycle_hire_osm` to `cycle_hire` based on proximity.
-   Use `st_is_within_distance()` to perform a distance-based join within 20 meters:

```{r}
st_is_within_distance(
  x = cycle_hire, 
  y = cycle_hire_osm, 
  dist = units::set_units(20, "m"))->sel
summary(lengths(sel) > 0)
```

-   Use `st_join()` to retrieve values from `cycle_hire_osm`:

```{r}
st_join(
  x = cycle_hire, 
  y = cycle_hire_osm, 
  join = st_is_within_distance, 
  dist = units::set_units(20, "m"))-> z
z %>% view
nrow(cycle_hire)
nrow(z)
```

-   Some `cycle_hire` stations have multiple matches. Use aggregation to combine these results:

```{r}
z %>%
  group_by(id) %>%
  summarize(capacity = mean(capacity))->z
nrow(z) == nrow(cycle_hire)
```

-   Verify the results by plotting:

```{r}
plot(cycle_hire_osm["capacity"])
plot(z["capacity"])
```

### 4.2.7 Spatial aggregation {#spatial-aggr}

-   Spatial aggregation condenses data so that the output has fewer rows than the input.
-   Functions like `mean()` or `sum()` summarize values for each grouping variable.
-   Use `aggregate()` for spatial objects:

```{r}
aggregate(x = nz_height, by = nz, FUN = mean)-> nz_agg
nz_agg
#double check its from stats pkg
```

-   This creates an `sf` object where the geometry is the same as the original, but the attributes are summarized.
-   Alternatively, use `st_join()` with `group_by()` and `summarize()`:

```{r}
st_join(x = nz, y = nz_height) %>%
  group_by(Name) %>%
  summarize(elevation = mean(elevation, na.rm = TRUE))->nz_agg2
nz_agg2
```

-   The key difference:
    -   `aggregate()`: Results in `NA` values for unmatched names.
    -   `group_by() %>% summarize()`: Preserves region names.

   
### 4.2.8 Joining incongruent layers {#incongruent}

-   Spatial congruence happens when two datasets share borders, useful for spatial aggregation.

-   Incongruent datasets do not share borders and require special methods for aggregation.

-   For example, to transfer values from smaller area (`incongruent`) to larger ones (`aggregating_zones`), use area-weighted interpolation:

```{r}
incongruent -> smallunits
aggregating_zones -> largerunits

smallunits %>%
  tm_shape(.) +
  tm_fill("value") +
  tm_shape(largerunits) +
  tm_borders()

agg_aw = st_interpolate_aw(
  x = smallunits["value"],
  to = largerunits, extensive = TRUE)
agg_aw$value
```

- This method sums up values for overlapping areas. 
- extensive: total income is a so-called spatially extensive variable (which increases with area), assuming income is evenly distributed across the smaller zones (hence the warning message above), use `extensive = TRUE`. 
- intensive: variables such as average income or percentages, which do not increase as the area increases. For spatially intensive variables (like averages), set `extensive = FALSE`.



# 4.3 Spatial Operations on Raster Data

This section builds on previous methods for manipulating raster datasets to demonstrate more advanced spatial raster operations, using the `elev` and `grain` objects from the **spData** package.

```{r}
library(terra)
library(ggplot2)

# Load the rasters
rast(system.file("raster/elev.tif", package = "spData")) -> elev
rast(system.file("raster/grain.tif", package = "spData")) -> grain

# Convert rasters to data frames
as.data.frame(elev, xy = TRUE, na.rm = TRUE)-> elev_df 
as.data.frame(grain, xy = TRUE, na.rm = TRUE)-> grain_df 

# Print column names to verify
print(names(elev_df))
print(names(grain_df))

# Plot using ggplot2
ggplot() + 
  geom_raster(data = elev_df, aes(x = x, y = y, fill = elev)) +
  scale_fill_viridis_c() + # Adjust color scale if needed
  labs(title = "Elevation Raster", x = "Longitude", y = "Latitude") +
  theme_minimal() +
  geom_text(data = elev_df, aes(x = x, y = y, label = round(elev, 1)), size = 2, color = "white")


ggplot() + 
  geom_raster(data = grain_df, aes(x = x, y = y, fill = grain)) +
  labs(title = "Grain Raster", x = "Longitude", y = "Latitude") +
  theme_minimal()


```

## 4.3.1 Spatial Subsetting

Raster objects can be subset by location (coordinates) and other spatial objects. Use `cellFromXY()` to translate coordinates into a cell ID, or `terra::extract()` to get cell values directly. 

To get the value at coordinates (0.1, 0.1):

```{r}
terra::cellFromXY(elev, xy = matrix(c(0.1, 0.1), ncol = 2)) -> id
elev[id] -> value
# or
terra::extract(elev, matrix(c(0.1, 0.1), ncol = 2)) -> extracted_value
```

To subset with another raster object:

```{r}
rast(
  xmin = 0.9, 
  xmax = 1.8, 
  ymin = -0.45,
  ymax = 0.45, 
  resolution = 0.3,
  vals = rep(1, 9)) -> clip
elev[clip] -> subset_elev

# or
# Crop the elevation raster using the extent of the clip
terra::crop(elev, ext(clip))-> subset_elev 

# Print and plot the subset to verify
print(subset_elev)
plot(subset_elev)
```

Spatial subsetting can also be done with logical rasters:

```{r}
elev[1:2, drop = FALSE] -> subset_raster
# to visualize
elev[1, 1:2, drop = FALSE] -> x
plot(x)
```

Creating and using a mask raster:

```{r}
elev[elev < 20] -> elev_masked
# create raster mask 
rmask = elev
sample(c(NA, TRUE), 36, replace = TRUE)-> values(rmask) 
```

For masking operations:

```{r}
elev[rmask, drop = FALSE] -> masked_elev
# or
mask(elev, rmask) -> masked_raster
```


## 4.3.2 Map algebra

The term **map algebra** refers to a set of techniques for analyzing geographic raster and vector data. In a narrower sense, it involves operations that modify or summarize raster cell values based on surrounding cells, zones, or statistical functions.

Map algebra operations are generally fast because raster datasets store only implicit coordinates. Processing is efficient as long as cell positions remain consistent. Datasets sharing the same extent, projection, and resolution can be treated as matrices for processing.

The **terra** package supports map algebra operations with four main types:

1. **Local** or per-cell operations
2. **Focal** or neighborhood operations
3. **Zonal** operations
4. **Global** or per-raster operations

### 4.3.3 Local operations

**Local** operations involve cell-by-cell calculations within one or more layers. Examples include arithmetic operations, logical operations, and classification. The **terra** package handles these operations efficiently.

```{r 04-spatial-operations-41, eval = FALSE}
elev + elev -> added_elev
elev^2 -> squared_elev
log(elev) -> log_elev
elev > 5 -> elev_greater_than_5
```

Classifying numeric values into groups (e.g., elevation classes) using the `classify()` function:

```{r 04-spatial-operations-40}
matrix(c(0, 12, 1, 12, 24, 2, 24, 36, 3), ncol = 3, byrow = TRUE) -> rcl
classify(elev, rcl = rcl) -> recl
```

Using `app()`, `tapp()`, and `lapp()` functions for efficient operations on large rasters:

```{r}
system.file("raster/landsat.tif", package = "spDataLarge") -> multi_raster_file
rast(multi_raster_file) -> multi_rast

(multi_rast * 0.0000275) - 0.2 -> multi_rast

multi_rast[multi_rast < 0] = 0

ndvi_fun = function(nir, red) {
  (nir - red) / (nir + red)
}

lapp(multi_rast[[c(4, 3)]], fun = ndvi_fun) -> ndvi_rast
```

### 4.3.4 Focal operations

**Focal** operations consider a central cell and its neighbors. A focal operation applies an aggregation function to the neighborhood and assigns the result to the central cell. 

Performing a focal operation to find the minimum value in a 3x3 window:

```{r 04-spatial-operations-42, eval = FALSE}
focal(elev, w = matrix(1, nrow = 3, ncol = 3), fun = min) -> r_focal
```

Focal functions are crucial in image processing, used for smoothing, edge detection, and terrain analysis. For example, calculating terrain metrics:

```{r}
terrain(elev, v = "slope") -> slope_raster
```



## 4.3.5 Zonal operations

**Zonal** operations aggregate raster cell values based on zones defined by a second raster with categorical values. Unlike focal operations, where cells must be neighbors, zonal operations can involve cells that are not adjacent. The result is a summary table grouped by zones, also known as **zonal statistics**.

Calculate the mean elevation for each grain size class using the `zonal()` function:

```{r 04-spatial-operations-43}
zonal(elev, grain, fun = "mean") -> z
print(z)-> z 
```

## 4.3.6 Global operations and distances

**Global** operations are a special case of zonal operations where the entire raster dataset is treated as a single zone. Common global operations include calculating descriptive statistics for the entire raster, such as the minimum or maximum.

Global operations are also useful for distance calculations. For example, calculating the distance to the nearest coast or incorporating topography by weighting distance with elevation. Visibility and viewshed computations also fall under global operations.

### 4.3.7 Map algebra counterparts in vector processing

Map algebra operations often have counterparts in vector processing:

- **Distance raster**: Equivalent to a vector buffer operation.
- **Reclassification**: Similar to dissolving vector data.
- **Overlaying rasters**: Comparable to vector clipping.
- **Intersecting layers**: Similar to spatial clipping but involves overlapping areas.

Be cautious of terminology differences between raster and vector data models.

### 4.3.8 Merging rasters

When working with remotely sensed data that spans multiple scenes, you may need to merge these scenes. Use the `merge()` function to combine rasters side by side:

```{r 04-spatial-operations-44, eval = FALSE}
geodata::elevation_30s(country = "AUT", path = tempdir()) -> aut
geodata::elevation_30s(country = "CHE", path = tempdir()) -> ch
merge(aut, ch) -> aut_ch
```

If overlapping areas have different values, consider using `mosaic()` to define a function for the overlap, such as calculating the mean to smooth the border.

## Exercises

```{r, echo=FALSE, results='asis'}
knitr::knit_child('_04-ex.Rmd', quiet = TRUE, options = list(include = FALSE, eval = FALSE)) -> res
cat(res, sep = '\n')
```

